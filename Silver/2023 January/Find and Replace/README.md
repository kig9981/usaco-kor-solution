# Find and Replace

문자열 $A$와 $B$가 주어질 때, 문자열 $A$의 임의의 문자를 다른 문자로 바꾸는 연산이 가능하다. 이때, $A$를 $B$로 바꿀 수 있으면 최소 연산 횟수를, 불가능하다면 -1을 출력하는 문제이다.   

먼저 불가능한 경우를 제거하도록 하자, 연산의 특성상 이미 같은 문자로써 하나의 그룹으로 묶인 문자는 절대로 최종 결과로 서로 다른 문자를 가질 수 없다. 즉, 문자열 $A$의 문자와 문자열 $B$의 문자는 서로 함수 관계를 갖는다. 따라서 함수 관계가 아니라면 -1을 출력한다. 다만, 함수 관계이면서 불가능한 경우가 추가로 존재하는데, 이는 문자열 $B$가 52개 종류의 알파벳이 모두 나타나면서 $A \ne{} B$인 경우이다.   

이렇게 2가지 경우를 제외하면 나머지 경우는 항상 가능하다. 각 문자가 하나의 문자에 대응되는 함수 관계이므로, 각 문자를 정점으로 하는 functional graph가 나옴을 알 수 있다. functional graph는 사이클의 존재 유무로 분류하여 문제를 해결하는 것이 일반적이므로, 사이클의 유무로 경우를 분류하여 생각해보자.   

첫 번째로 사이클이 없는 컴포넌트인 경우이다. 이 경우 그래프를 따라가게 되면 최종 도착점이 self-loop를 띄게된다. 이러한 형태는 그래프의 방향을 뒤집은 뒤, 위상정렬을 한 순서로 연산을 수행하면 원하는 상태로 만들 수 있으며, 이 경우 최소 연산 횟수는 (컴포넌트의 크기)-1 이다.

두 번째로 사이클이 존재하는 컴포넌트이다. 이 경우 functional graph의 특성상 단 하나의 사이클이 존재하며, 이 사이클을 분리시키면 앞서 다룬 첫번째 경우와 동일함을 알 수 있다. 따라서 사이클을 끊는데 비용에 집중하도록 하자.   

만약 주어진 컴포넌트가 오로지 하나의 사이클로만 구성된 경우에는 2번의 연산이 추가로 든다. 최종 결과인 $B$에 나타나지 않은 문자로 임시로 옮긴 뒤 다시 돌아오는 형태를 갖게 되기 때문이다. 반면, 사이클 이외에 다른 노드들이 컴포넌트에 속한다면 이 경우는 1번의 추가 연산이 필요하다. 즉, 외부로 옮기고 돌아오는 과정 없이 해결이 가능하다는 뜻이며, $A=abcdef$, $B=dddffb$인 경우를 생각해보면 답이 6임을 알 수 있다.   

따라서 정리하면, 불가능한 경우를 먼저 제거하고 최종 정답은 ($A$에서 나타난 문자의 종류)-(self-loop가 나타나는 문자의 종류)+(functional graph에서 오로지 사이클로만 이루어진 컴포넌트의 개수)가 답이 되며, functional graph를 만드는데 $O(N)$이 걸리므로 $O(N)$에 문제가 해결된다.